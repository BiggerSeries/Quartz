plugins {
    id 'java-library'
    id 'eclipse'
    id 'idea'
    id 'maven-publish'
    id 'net.neoforged.gradle.userdev' version '7.0.+'
    id 'net.neoforged.gradle.mixin' version '7.0.+'
}

evaluationDependsOn(':Phosphophyllite')

version = "${majorVersion}.${minorVersion}.${patchVersion}"
if (!"${postfix}".isEmpty()) {
    version += "-${postfix}"
    if (!"$postfixMajorVersion".isEmpty()) {
        version += ".${postfixMajorVersion}"
        if (!"$postfixMinorVersion".isEmpty()) {
            version += ".${postfixMinorVersion}"
        }
    }
}

group = "net.roguelogix.${mod_id}"
base {
    archivesName = "${mod_id}-${mc_version}"
}

// allows you to override quartz's forge version, just have to use the same key i use
neo_version = project.rootProject.property("neo_version")

setProperty("compatibility", "[" + version + ", ${majorVersion}." + ("${minorVersion}".toInteger() + 1).toString() + ".0-alpha)")
if (version.contains("alpha") || version.contains("beta")) {
    def nextIncompatibleVersion = "${majorVersion}.${minorVersion}.${patchVersion}-${postfix}"
    if (!"$postfixMajorVersion".isEmpty()) {
        nextIncompatibleVersion += "." + ("${postfixMajorVersion}".toInteger() + 1).toString()
    } else {
        nextIncompatibleVersion += ".1"
    }
    setProperty("compatibility", "[" + version + ", " + nextIncompatibleVersion + ")")
}

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

accessTransformers {
    file 'src/main/resources/META-INF/accesstransformer.cfg'
}


runs {
    configureEach {
        workingDirectory project.file("run/${it.name}")

        systemProperty 'forge.logging.markers', 'SCAN,REGISTRIES'
        systemProperty 'forge.logging.console.level', 'debug'

        modSource project.sourceSets.main
        modSource project.sourceSets.test
        modSource project(':Phosphophyllite').sourceSets.main

        dependencies {
            runtime("org.lwjgl:lwjgl-vulkan:3.3.1") {
                transitive(false)
            }
        }
    }

    client {
        systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
    }

    server {
        systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
        programArgument '--nogui'
    }

    gameTestServer {
        systemProperty 'forge.enabledGameTestNamespaces', project.mod_id
    }

    data {
        programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
    }
}

// Include resources generated by data generators.
sourceSets.main.resources { srcDir 'src/generated/resources' }

repositories {
    maven {
        url = "https://www.cursemaven.com"
    }
}

dependencies {
    implementation "net.neoforged:neoforge:${neo_version}"

    compileOnly project(':Phosphophyllite')
    testCompileOnly project(':Phosphophyllite')
    compileOnly("org.lwjgl:lwjgl-vulkan:3.3.1") {
        transitive(false)
    }

    compileOnly 'curse.maven:Rubidium-574856:4684247'
    compileOnly 'curse.maven:Oculus-581495:4578741'
}

gradle.projectsEvaluated {
    var phosVersionRangeString = project.rootProject.project('Phosphophyllite').property("compatibility").toString();
    // if this fails, phos was not configured immediately before, and this is IDEA running idePostSync
    // doesnt need to be run, but whatever, it gets run, and i cant find a way to stop it, this keeps it from failing though
    if(!phosVersionRangeString.isEmpty()) {
        var phosVersionRange = phosVersionRangeString.split(',')
        var phosMinVersion = phosVersionRange[0].substring(1)
        var phosMaxVersion = phosVersionRange[1].substring(1, phosVersionRange[1].length() - 1)
        var phosRequirementString = "Requires [Phosphophyllite](https://www.curseforge.com/minecraft/mc-mods/phosphophyllite) version of at least " + phosMinVersion + " but less than " + phosMaxVersion

        println("::set-output name=phos_version_range::" + phosRequirementString)

        tasks.withType(ProcessResources).configureEach {
            var replaceProperties = [
                    minecraft_version : mc_version,
                    neo_version       : neo_version,
                    loader_version    : loader_version,
                    version           : version,
                    phos_version_range: phosVersionRangeString,
            ]
            inputs.properties replaceProperties

            filesMatching(['META-INF/mods.toml']) {
                expand replaceProperties + [project: project]
            }
        }
    }
}

tasks.named('jar', Jar).configure {
    manifest {
        attributes([
                'Specification-Title'     : mod_id,
                'Specification-Vendor'    : "BiggerSeries",
                'Specification-Version'   : '1', // We are version 1 of ourselves
                'Implementation-Title'    : project.name,
                'Implementation-Version'  : project.jar.archiveVersion,
                'Implementation-Vendor'   : "BiggerSeries",
                'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

tasks.named('publish').configure {
    dependsOn 'reobfJar'
    mustRunAfter 'reobfJar'
}

tasks.register('sourcesJar', Jar) {
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
}

artifacts {
    archives jar
    archives sourcesJar
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            artifact jar
            artifact sourcesJar
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/publishlocal"
        }
    }
}

// NeoGradle bug, this works around it
gradle.projectsEvaluated {
    var subProject = project.project(':Phosphophyllite')

    var neoFormJoinDownloadAssetsTaskName = null
    for (final def taskName in project.tasks.getNames()) {
        if (taskName.contains("neoFormJoined") && taskName.contains("DownloadAssets")) {
            neoFormJoinDownloadAssetsTaskName = taskName
            break
        }
    }

    try {
    project.tasks.getByPath(neoFormJoinDownloadAssetsTaskName).mustRunAfter(subProject.tasks.getByPath(neoFormJoinDownloadAssetsTaskName))
    } catch (UnknownTaskException e){
    }
}